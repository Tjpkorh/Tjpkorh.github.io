<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>FMI Historical Weather Viewer (Enhanced)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Chart.js CDN only -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
  <style>
    :root {
      color-scheme: light dark;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      margin: 0;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    header {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
    }

    h1 {
      font-size: 1.1rem;
      margin: 0;
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 0.75rem;
      align-items: flex-end;
    }

    label {
      display: flex;
      flex-direction: column;
      font-size: 0.85rem;
      gap: 0.25rem;
    }

    input, select, button {
      padding: 0.4rem 0.5rem;
      font: inherit;
    }

    button {
      cursor: pointer;
    }

    .station-search {
      position: relative;
    }

    .station-results {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      max-height: 220px;
      overflow: auto;
      border: 1px solid #888;
      background: #fff;
      color: #000;
      z-index: 10;
      font-size: 0.85rem;
    }

    .station-results div {
      padding: 0.3rem 0.5rem;
      cursor: pointer;
    }

    .station-results div:hover {
      background: #eef;
    }

    .status {
      font-size: 0.85rem;
      min-height: 1.2em;
    }

    .chart-wrapper {
      position: relative;
      height: 60vh;
      max-height: 600px;
    }

    @media (max-width: 600px) {
      .chart-wrapper {
        height: 50vh;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>FMI Historical Weather Viewer</h1>
    <div class="status" id="status">Ready</div>
  </header>

  <section class="controls">
    <div class="station-search">
      <label>
        Weather station
        <input type="text" id="stationSearch" placeholder="Search station by name or FMISID..." autocomplete="off" />
      </label>
      <div class="station-results" id="stationResults" hidden></div>
      <input type="hidden" id="selectedStationId" />
    </div>

    <label>
      Parameter
      <select id="parameter">
        <optgroup label="Temperature">
          <option value="t2m">Air temp 2m (°C) [t2m]</option>
          <option value="td">Dew point (°C) [td]</option>
        </optgroup>
        <optgroup label="Wind">
          <option value="ws_10min">Wind speed 10min (m/s) [ws_10min]</option>
          <option value="wg_10min">Wind gust 10min (m/s) [wg_10min]</option>
          <option value="wd_10min">Wind dir 10min (°) [wd_10min]</option>
        </optgroup>
        <optgroup label="Humidity">
          <option value="rh%">Rel humidity (%) [rh%]</option>
        </optgroup>
        <optgroup label="Pressure">
          <option value="p-sealevel">Pressure sea level (hPa) [p-sealevel]</option>
          <option value="p-mrh">Pressure MRH (hPa) [p-mrh]</option>
        </optgroup>
        <optgroup label="Precipitation">
          <option value="r_1h">Rain 1h (mm) [r_1h]</option>
          <option value="r_6h">Rain 6h (mm) [r_6h]</option>
          <option value="r_12h">Rain 12h (mm) [r_12h]</option>
          <option value="r_24h">Rain 24h (mm) [r_24h]</option>
          <option value="snow_24h">Snow 24h (mm) [snow_24h]</option>
        </optgroup>
        <optgroup label="Other">
          <option value="vis">Visibility (m) [vis]</option>
          <option value="n_man">Cloud amount (okta) [n_man]</option>
          <option value="wawa">Present weather [wawa]</option>
        </optgroup>
      </select>
    </label>

    <label>
      Timestep (min)
      <select id="timestep">
        <option value="10">10 min</option>
        <option value="30">30 min</option>
        <option value="60" selected>1 hour</option>
        <option value="360">6 hours</option>
        <option value="720">12 hours</option>
        <option value="1440">24 hours</option>
      </select>
    </label>

    <label>
      Start (UTC)
      <input type="datetime-local" id="startTime" />
    </label>

    <label>
      End (UTC)
      <input type="datetime-local" id="endTime" />
    </label>

    <button id="fetchBtn">Fetch &amp; plot</button>
  </section>

  <section class="chart-wrapper">
    <canvas id="weatherChart"></canvas>
  </section>

  <script>
    const FMI_BASE = "https://opendata.fmi.fi/wfs";

    const statusEl = document.getElementById("status");
    const stationSearchInput = document.getElementById("stationSearch");
    const stationResultsEl = document.getElementById("stationResults");
    const selectedStationIdInput = document.getElementById("selectedStationId");
    const startTimeInput = document.getElementById("startTime");
    const endTimeInput = document.getElementById("endTime");
    const parameterSelect = document.getElementById("parameter");
    const timestepSelect = document.getElementById("timestep");
    const fetchBtn = document.getElementById("fetchBtn");
    const ctx = document.getElementById("weatherChart").getContext("2d");

    let stationList = [];
    let chart;

    // Helper: set status line
    function setStatus(msg, isError = false) {
      statusEl.textContent = msg || "";
      statusEl.style.color = isError ? "red" : "inherit";
    }

    // Helper: convert datetime-local to ISO string with Z
    function toIsoUtc(localValue) {
      if (!localValue) return null;
      const date = new Date(localValue);
      return date.toISOString().replace(/\.\d{3}Z$/, "Z");
    }

    // 1) Load stations (UNCHANGED - WORKING)
    async function loadStations() {
      const url = new URL(FMI_BASE);
      url.searchParams.set("service", "WFS");
      url.searchParams.set("version", "2.0.0");
      url.searchParams.set("request", "getFeature");
      url.searchParams.set("storedquery_id", "fmi::ef::stations");

      setStatus("Loading stations...");
      try {
        const res = await fetch(url.toString());
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const text = await res.text();

        const parser = new DOMParser();
        const xml = parser.parseFromString(text, "application/xml");

        const features = Array.from(
          xml.getElementsByTagNameNS("*", "FeatureCollection")[0]
            ?.getElementsByTagNameNS("*", "member") || []
        );

        stationList = features.map((member) => {
          const feature = member.firstElementChild;
          if (!feature) return null;

          const nameEl = feature.getElementsByTagNameNS("*", "name")[0] || feature.getElementsByTagName("gml:name")[0];
          const name = nameEl?.textContent?.trim() || "";

          const idEl = feature.getElementsByTagNameNS("*", "identifier")[0] || feature.getElementsByTagName("gml:identifier")[0];
          const identifier = idEl?.textContent?.trim() || "";

          const fmisidEl = feature.getElementsByTagName("fmisid")[0];
          const fmisid = fmisidEl?.textContent?.trim() || identifier;

          const latEl = feature.getElementsByTagNameNS("*", "pos")[0] || feature.getElementsByTagName("gml:pos")[0];
          let lat = null, lon = null;
          if (latEl) {
            const parts = latEl.textContent.trim().split(/\s+/);
            if (parts.length >= 2) {
              lat = parseFloat(parts[0]);
              lon = parseFloat(parts[1]);
            }
          }

          return { name, fmisid, identifier, lat, lon };
        }).filter(Boolean);

        setStatus(`Loaded ${stationList.length} stations.`);
      } catch (err) {
        console.error(err);
        setStatus("Failed to load stations from FMI.", true);
      }
    }

    // Station search UI (UNCHANGED - WORKING)
    function renderStationResults(filterText) {
      const q = filterText.trim().toLowerCase();
      if (!q) {
        stationResultsEl.hidden = true;
        stationResultsEl.innerHTML = "";
        return;
      }

      const matches = stationList.filter((s) => {
        return (
          s.name.toLowerCase().includes(q) ||
          (s.fmisid && s.fmisid.toLowerCase().includes(q)) ||
          (s.identifier && s.identifier.toLowerCase().includes(q))
        );
      }).slice(0, 50);

      if (!matches.length) {
        stationResultsEl.innerHTML = "<div>No matches</div>";
        stationResultsEl.hidden = false;
        return;
      }

      stationResultsEl.innerHTML = matches
        .map((s) => `<div data-fmisid="${s.fmisid}">${s.name || "(no name)"} — FMISID ${s.fmisid}${s.lat && s.lon ? ` (${s.lat.toFixed(3)}, ${s.lon.toFixed(3)})` : ''}</div>`)
        .join("");

      stationResultsEl.hidden = false;
    }

    stationSearchInput.addEventListener("input", (e) => renderStationResults(e.target.value));
    stationResultsEl.addEventListener("click", (e) => {
      const div = e.target.closest("div[data-fmisid]");
      if (!div) return;
      const fmisid = div.dataset.fmisid;
      const station = stationList.find((s) => s.fmisid === fmisid);
      if (station) {
        stationSearchInput.value = `${station.name} — FMISID ${station.fmisid}`;
        selectedStationIdInput.value = station.fmisid;
        stationResultsEl.hidden = true;
      }
    });
    document.addEventListener("click", (e) => {
      if (!stationResultsEl.contains(e.target) && e.target !== stationSearchInput) {
        stationResultsEl.hidden = true;
      }
    });

    // 3) Fetch time series (UPDATED with timestep)
    async function fetchTimeSeries(fmisid, parameter, startIso, endIso, timestep) {
      const url = new URL(FMI_BASE);
      url.searchParams.set("service", "WFS");
      url.searchParams.set("version", "2.0.0");
      url.searchParams.set("request", "getFeature");
      url.searchParams.set("storedquery_id", "fmi::observations::weather::timevaluepair");
      url.searchParams.set("fmisid", fmisid);
      url.searchParams.set("parameters", parameter);
      if (startIso) url.searchParams.set("starttime", startIso);
      if (endIso) url.searchParams.set("endtime", endIso);
      if (timestep) url.searchParams.set("timestep", timestep);  // ✅ NEW

      const res = await fetch(url.toString());
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const text = await res.text();

      const parser = new DOMParser();
      const xml = parser.parseFromString(text, "application/xml");

      const points = Array.from(xml.getElementsByTagNameNS("*", "MeasurementTVP"));
      const labels = [];
      const values = [];

      points.forEach((p) => {
        const timeEl = p.getElementsByTagNameNS("*", "time")[0];
        const valueEl = p.getElementsByTagNameNS("*", "value")[0];
        if (!timeEl || !valueEl) return;

        const t = timeEl.textContent.trim();
        const v = parseFloat(valueEl.textContent.trim());
        if (!Number.isNaN(v)) {
          labels.push(new Date(t));
          values.push(v);
        }
      });

      return { labels, values };
    }

    // 4) Chart (UNCHANGED - WORKING CATEGORY SCALE)
    function updateChart(labels, values, labelText) {
      const formattedLabels = labels.map((date) => 
        date.toLocaleString('sv-FI', { 
          year: 'numeric', month: '2-digit', day: '2-digit', 
          hour: '2-digit', minute: '2-digit', hour12: false 
        }).replace(' ', 'T')
      );

      const data = {
        labels: formattedLabels,
        datasets: [{
          label: labelText,
          data: values,
          borderColor: "rgb(75, 192, 192)",
          backgroundColor: "rgba(75, 192, 192, 0.3)",
          tension: 0.15,
          pointRadius: 1.5,
          fill: true,
        }],
      };

      const options = {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: {
            type: "category",
            ticks: { maxRotation: 45, autoSkip: true, maxTicksLimit: 12 },
          },
          y: { beginAtZero: false },
        },
        plugins: {
          legend: { display: true },
          tooltip: { mode: "index", intersect: false },
        },
      };

      if (!chart) {
        chart = new Chart(ctx, { type: "line", data, options });
      } else {
        chart.data = data;
        chart.options = options;
        chart.update("none");
      }
    }

    // 5) Button handler (UPDATED with timestep)
    fetchBtn.addEventListener("click", async () => {
      const fmisid = selectedStationIdInput.value.trim();
      if (!fmisid) {
        setStatus("Select a station first.", true);
        return;
      }

      const param = parameterSelect.value;
      const timestep = timestepSelect.value;
      const startIso = toIsoUtc(startTimeInput.value);
      const endIso = toIsoUtc(endTimeInput.value);

      if (!startIso || !endIso) {
        setStatus("Set both start and end time.", true);
        return;
      }

      setStatus(`Fetching ${param} (${timestep}min step)...`);
      fetchBtn.disabled = true;

      try {
        const { labels, values } = await fetchTimeSeries(
          fmisid, param, startIso, endIso, timestep
        );

        if (!labels.length) {
          setStatus("No data for selected period/parameter.", true);
          fetchBtn.disabled = false;
          return;
        }

        const station = stationList.find((s) => s.fmisid === fmisid);
        updateChart(labels, values, `${param} (${timestep}min) at ${station?.name || fmisid}`);
        setStatus(`Plotted ${labels.length} points (${timestep}min step).`);
      } catch (err) {
        console.error(err);
        setStatus(`Error: ${err.message}`, true);
      } finally {
        fetchBtn.disabled = false;
      }
    });

    // 6) Initialize (UNCHANGED)
    (function init() {
      const now = new Date();
      const endLocal = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), now.getUTCHours(), 0, 0));
      const startLocal = new Date(endLocal.getTime() - 24 * 60 * 60 * 1000);

      const toLocalInput = (d) => {
        const pad = (n) => String(n).padStart(2, "0");
        return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}`;
      };

      startTimeInput.value = toLocalInput(startLocal);
      endTimeInput.value = toLocalInput(endLocal);

      loadStations();
    })();
  </script>
</body>
</html>
